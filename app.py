import os
import base64
import re
import unicodedata
from flask import Flask, render_template, request, url_for, session, jsonify, redirect
from werkzeug.utils import secure_filename
from dotenv import load_dotenv
from openai import OpenAI
from PIL import Image
from pdf2image import convert_from_path
import tempfile
from authlib.integrations.flask_client import OAuth
from flask_openid import OpenID
import mysql.connector


# Carregar vari√°veis do .env
load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
STEAM_API_KEY = os.getenv("STEAM_API_KEY")
DISCORD_CLIENT_ID = os.getenv("DISCORD_CLIENT_ID")
DISCORD_CLIENT_SECRET = os.getenv("DISCORD_CLIENT_SECRET")
TWITCH_CLIENT_ID = os.getenv("TWITCH_CLIENT_ID")
TWITCH_CLIENT_SECRET = os.getenv("TWITCH_CLIENT_SECRET")

app = Flask(__name__)
app.secret_key = os.getenv("SECRET_KEY")
app.debug = True
UPLOAD_FOLDER = 'static/uploads'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'webp', 'pdf'}

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="FuriaDB"
)
cursor = db.cursor()

def coletar_dados():
    if request.method == 'POST':
        nome = request.form['nome']
        email = request.form['email']
        endereco = request.form['endereco']
        cpf = request.form['cpf']
        atividades = request.form['atividades']
        eventos = request.form['eventos']
        compras = request.form['compras']
        link_perfil = request.form['link_perfil']
        interesses = request.form.getlist('interesse')

        # Salvando os dados no banco
        sql = '''
        INSERT INTO DadoFans (nome, email, endereco, cpf, atividades, eventos, compras, links)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        '''
        valores = (nome, email, endereco, cpf, atividades, eventos, compras, link_perfil)
        cursor.execute(sql, valores)
        db.commit()

        # Passando os dados para o template 'result.html'
        data = {
            'nome': nome,
            'email': email,
            'endereco': endereco,
            'cpf': cpf,
            'atividades': atividades,
            'eventos': eventos,
            'compras': compras,
            'link_perfil': link_perfil,
            'interesses': interesses, # Exemplo de retorno da an√°lise de link
        }

        return render_template('result.html', data=data)

    return render_template('index.html')

oid = OpenID(app)
oauth = OAuth(app)

steam = oauth.register(
    'steam',
    client_id='STEAM_API_KEY',
    authorize_url='https://steamcommunity.com/openid/login',
    access_token_url=None,
    client_kwargs={'scope': 'openid'},
)

# Configura√ß√£o do Discord OAuth
discord = oauth.register(
    'discord',
    client_id=os.getenv('DISCORD_CLIENT_ID'),
    client_secret=os.getenv('DISCORD_CLIENT_SECRET'),
    authorize_url='https://discord.com/oauth2/authorize',
    access_token_url='https://discord.com/api/oauth2/token',
    refresh_token_url=None,
    client_kwargs={'scope': 'identify email'},
)

# Configura√ß√£o do Twitch OAuth
twitch = oauth.register(
    'twitch',
    client_id=os.getenv('TWITCH_CLIENT_ID'),
    client_secret=os.getenv('TWITCH_CLIENT_SECRET'),
    authorize_url='https://id.twitch.tv/oauth2/authorize',
    access_token_url='https://id.twitch.tv/oauth2/token',
    refresh_token_url=None,
    client_kwargs={'scope': 'user:read:email'},
)

# Rota para Steam OAuth
@app.route('/login/steam')
def login_steam():
    # Indica que a resposta de autentica√ß√£o deve ser enviada para 'auth_steam'
    redirect_uri = url_for('auth_steam', _external=True)
    return steam.authorize_redirect(redirect_uri)

@app.route('/login/steam/authorized')
def auth_steam():
    token = steam.authorize_access_token()
    
    # Processa os dados retornados ap√≥s a autentica√ß√£o
    user_info = steam.get('https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/', token=token)
    
    # Salva o nome do usu√°rio na sess√£o
    session['user'] = {'name': user_info.json()['response']['players'][0]['personaname']}
    
    return redirect(url_for('index'))

# Rota para Discord OAuth
@app.route('/login/discord')
def login_discord():
    redirect_uri = 'https://127.0.0.1:5000/login/discord/authorized'
    return discord.authorize_redirect(redirect_uri)

# Rota para Twitch OAuth
@app.route('/login/twitch')
def login_twitch():
    redirect_uri = url_for('auth_twitch', _external=True)
    return twitch.authorize_redirect(redirect_uri)

# Callback de autentica√ß√£o para Steam
def auth_steam():
    # Verifica se a autentica√ß√£o foi bem-sucedida
    if oid.verify():
        user_info = oid.fetch()
        # Armazenar as informa√ß√µes do usu√°rio na sess√£o
        session['user'] = {'name': user_info}
        return redirect(url_for('index'))

# Callback de autentica√ß√£o para Discord
@app.route('/login/discord/authorized')
def auth_discord():
    token = discord.authorize_access_token()
    user_info = discord.get('https://discord.com/api/v10/users/@me', token=token)
    session['user'] = {'name': user_info.json()['username']}
    return redirect(url_for('index'))

# Callback de autentica√ß√£o para Twitch
@app.route('/login/twitch/authorized')
def auth_twitch():
    token = twitch.authorize_access_token()
    user_info = twitch.get('https://api.twitch.tv/helix/users', token=token)
    session['user'] = {'name': user_info.json()['data'][0]['display_name']}
    return redirect(url_for('index'))

# P√°gina inicial
@app.route('/')
def index():
    if 'user' in session:
        return f'Ol√°, {session["user"]["name"]}'
    return render_template('index.html')

os.makedirs(UPLOAD_FOLDER, exist_ok=True)

def normalize_text(text):
    """Normaliza texto removendo acentos e convertendo para min√∫sculas"""
    text = unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode()
    return text.lower().strip()

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def encode_image(image_path):
    """Codifica a imagem em base64"""
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

def process_file(filepath):
    """Processa diferentes tipos de arquivo"""
    if filepath.lower().endswith('.pdf'):
        with tempfile.TemporaryDirectory() as temp_dir:
            images = convert_from_path(filepath, dpi=300, output_folder=temp_dir, 
                                     first_page=1, last_page=1, fmt='jpeg')
            if not images:
                raise ValueError("Falha ao converter PDF")
            temp_img_path = os.path.join(temp_dir, 'temp_page.jpg')
            images[0].save(temp_img_path, 'JPEG')
            return temp_img_path
    return filepath

def mask_cpf(cpf):
    """Mascara o CPF para exibi√ß√£o"""
    return f"{cpf[:3]}.***.***-{cpf[-2:]}" if len(cpf) == 11 else cpf

def validate_cpf(cpf):
    """Valida o formato b√°sico do CPF"""
    return re.match(r"^\d{11}$", cpf) is not None

@app.route('/', methods=['GET', 'POST'])
def form():
    status_emoji = {
        "VALIDADO": "‚úÖ DOCUMENTO VALIDADO",
        "N√ÉO VALIDADO": "‚ùå DOCUMENTO N√ÉO VALIDADO",
        "INDETERMINADO": "‚ö†Ô∏è STATUS INDETERMINADO"
    }

    if request.method == 'POST':
        # Coletar dados do formul√°rio
        cpf = request.form['cpf'].strip().replace('.', '').replace('-', '')
        link_perfil = request.form.get('link_perfil', '').strip()

        # Normalizar nome do usu√°rio
        form_data = {
            'nome': request.form['nome'].strip(),
            'email': request.form['email'].strip(),
            'endereco': request.form['endereco'].strip(),
            'cpf': mask_cpf(cpf),
            'interesses': request.form.getlist('interesse'),
            'atividades': request.form['atividades'].strip(),
            'eventos': request.form['eventos'].strip(),
            'compras': request.form['compras'].strip(),
            'resultado_ia': "Nenhum documento enviado.",
            'link_perfil': link_perfil,
            'resultado_ia': "Nenhum documento enviado.",
            'resultado_link': "Nenhum link enviado."
        }
        
        
        # Verifica se o CPF √© v√°lido
        if not validate_cpf(cpf):
            form_data['resultado_link'] = "üö® CPF inv√°lido"
            return render_template('error.html', message="CPF inv√°lido", data=form_data), 400

        if link_perfil:
            try:
                # Requisi√ß√£o para a IA analisar o link
                link_response = client.chat.completions.create(
                    model="gpt-4-turbo",
                    messages=[ 
                        {
                            "role": "system",
                            "content": (
                                "Voc√™ √© uma IA que avalia perfis online. "
                                "Analise o conte√∫do de um link de perfil de e-sports ou qualquer outro conte√∫do online que "
                                "possa estar relacionado a organiza√ß√µes como a FURIA, times de e-sports ou interesses gerais em e-sports.\n"
                                "Responda da seguinte forma:\n"
                                "STATUS: Relevante/Irrelevante\n"
                                "JUSTIFICATIVA: [explica√ß√£o clara e detalhada sobre oque √© relevante para a pessoa baseado no link e ligue com a furia]"
                            )
                        },
                        {
                            "role": "user",
                            "content": f"Link do perfil: {link_perfil}\nInteresses: {', '.join(form_data['interesses'])}"
                        }
                    ],
                    temperature=0.2,
                    max_tokens=500
                )

                raw_link_resp = link_response.choices[0].message.content.strip()
                status_link = "INDETERMINADO"
                justificativa_link = "Resposta n√£o interpretada"

                # Verificar se a resposta cont√©m a estrutura de status e justificativa
                if "STATUS:" in raw_link_resp and "JUSTIFICATIVA:" in raw_link_resp:
                    status_match = re.search(r"STATUS:\s*(Relevante|Irrelevante)", raw_link_resp, re.IGNORECASE)
                    justificativa_match = re.search(r"JUSTIFICATIVA:\s*(.+)", raw_link_resp, re.DOTALL)

                    if status_match and justificativa_match:
                        status_link = status_match.group(1).capitalize()
                        justificativa_link = justificativa_match.group(1).strip()

                form_data['resultado_link'] = (
                    f"{'‚úÖ Perfil Relevante' if status_link == 'Relevante' else '‚ùå Perfil Irrelevante'}\n"
                    f"Justificativa: {justificativa_link}"
                )

            except Exception as e:
                form_data['resultado_link'] = f"üö® ERRO: {str(e)}"
                app.logger.error(f"Erro na an√°lise do link: {str(e)}")

        documento = request.files['documento']
        if documento and allowed_file(documento.filename):
            filename = secure_filename(documento.filename)
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            documento.save(filepath)

            try:
                # Processar arquivo (PDF ou imagem)
                processed_path = process_file(filepath)
                img = Image.open(processed_path)
                img.thumbnail((1024, 1024))
                if img.mode in ('RGBA', 'P'):
                    img = img.convert('RGB')
                img.save(processed_path)
                base64_image = encode_image(processed_path)

                # Chamada √† API para validar o documento
                response = client.chat.completions.create(
    model="gpt-4-turbo",
    messages=[
    {
        "role": "system",
        "content": "Voc√™ √© um validador de documentos. Analise a imagem fornecida comparando com os dados: Nome: {nome} CPF: {cpf} Sua resposta DEVE seguir EXATAMENTE este formato: STATUS: [VALIDADO/N√ÉO VALIDADO] JUSTIFICATIVA: [Explica√ß√£o detalhada da decis√£o] ATEN√á√ÉO PARA NUMEROS SEMELHANTES ESCRITOS COMO 5 e 6 E LETRAS SEMELHANTES COMO S E Z Crit√©rios:1. VALIDADO se:- Nome e CPF na imagem coincidem com os dados fornecidos - Documento parece aut√™ntico e leg√≠vel 2. N√ÉO VALIDADO se: - Qualquer diverg√™ncia nos dados - Documento ileg√≠vel, adulterado ou incompleto"  # Mantenha seu system prompt   
    },
    {
        "role": "user", 
        "content": [
            {
                "type": "text",
                "text": f"Verifique se o documento cont√©m:\nNome: {form_data['nome']}\nCPF: {cpf}"
            },
            {
                "type": "image_url",
                "image_url": {
                    "url": f"data:image/jpeg;base64,{base64_image}"
                }
            }
        ]
    }
    ],
    temperature=0.0,
    max_tokens=150
)

                

                # Padr√µes melhorados com flexibilidade
                status_pattern = r"(?i)(status|resultado|valida√ß√£o)\s*[:.-]?\s*(validado|n√£o validado|nao validado|inv√°lido|invalido|aprovado|reprovado|negado|incorreto)"
                justificativa_pattern = r"(?i)(justificativa|motivo|raz√£o|explica√ß√£o|an√°lise)\s*[:.-]?\s*(.*?)(?=(status|resultado|valida√ß√£o|$))"
                
                
                status_mapping = {
                    'validado': 'VALIDADO',
                    'aprovado': 'VALIDADO',
                    'reprovado': 'N√ÉO VALIDADO',
                    'inv√°lido': 'N√ÉO VALIDADO', 
                    'invalido': 'N√ÉO VALIDADO',
                    'nao validado': 'N√ÉO VALIDADO',
                    'n√£o validado': 'N√ÉO VALIDADO',
                    'negado': 'N√ÉO VALIDADO',
                    'incorreto': 'N√ÉO VALIDADO'
                }

                # Processar resposta
                raw_response = response.choices[0].message.content.strip()
                status = "INDETERMINADO"
                justificativa = "Resposta n√£o interpretada"
                
                status_match = re.search(status_pattern, raw_response, re.DOTALL | re.IGNORECASE)
                justificativa_match = re.search(justificativa_pattern, raw_response, re.DOTALL | re.IGNORECASE)
                
                # Normalizar status
                if status_match:
                    raw_status = status_match.group(2).strip().lower()
                    status = status_mapping.get(raw_status, 'INDETERMINADO')

                # Capturar justificativa
                if justificativa_match:
                    justificativa = justificativa_match.group(2).strip()
                    justificativa = re.sub(r'\s+', ' ', justificativa)  # Remover espa√ßos m√∫ltiplos
                
                # Fallback 1 - Busca contextual
                if status == 'INDETERMINADO':
                    if any(palavra in raw_response.lower() for palavra in ["confere", "correto", "coincide", "match"]):
                        status = "VALIDADO"
                    elif any(palavra in raw_response.lower() for palavra in ["n√£o confere", "incorreto", "divergente", "errado"]):
                        status = "N√ÉO VALIDADO"
                        
                # Fallback 2 - An√°lise de sentimento
                if status == 'INDETERMINADO':
                    positive_words = ['valid', 'correct', 'match', 'positiv']
                    negative_words = ['invalid', 'incorrect', 'mismatch', 'negativ']
                    
                    if any(word in raw_response.lower() for word in positive_words):
                        status = "VALIDADO"
                    elif any(word in raw_response.lower() for word in negative_words):
                        status = "N√ÉO VALIDADO"
                        
                # Atualizar com matches encontrados
                if status_match:
                    status = status_match.group(2).upper()
                    status = "N√ÉO VALIDADO" if status in ["NAO VALIDADO", "INVALIDO", "INV√ÅLIDO", "REPROVADO"] else status
                    
                if justificativa_match:
                    justificativa = justificativa_match.group(2).strip()
                    
                status = status if status in ["VALIDADO", "N√ÉO VALIDADO"] else "INDETERMINADO"

                form_data['resultado_ia'] = (
                    f"{status_emoji.get(status, status_emoji['INDETERMINADO'])}\n"
                    f"Justificativa: {justificativa}"
                )

            except Exception as e:
                form_data['resultado_ia'] = f"üö® ERRO: {str(e)}"
                app.logger.error(f"Erro: {str(e)}")

        return render_template('result.html', data=form_data)
    
    return render_template('index.html')

if __name__ == '__main__':
    context = ('cert.pem', 'key.pem')  # Certificado e chave privada
    app.run(host='127.0.0.1', port=5000, ssl_context=context)
    app.run(debug=True)